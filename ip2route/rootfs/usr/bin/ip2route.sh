#!/bin/bash -e
# ip route management script.
# Copyright (c) Chen Fang 2023, mtdcy.chen@gmail.com.
# 
# v0.3      - 20250421, modify for docker usage
# v0.2.1    - 20240613, add echocmd and fix tcpmss
# v0.2      - 20231125, code refactoring.
# 				   ...
# v0.1      - initial version

# root privilege is required
[ "$(id -u)" -eq 0 ] || exec sudo "$0" "$@"

# options           .
         IP2ROUTE_ID="${IP2ROUTE_ID:-1}"
        IP2ROUTE_DEV="${IP2ROUTE_DEV:-tun0}"
     IP2ROUTE_SERVER="${IP2ROUTE_SERVER:-8.8.8.8}"
       IP2ROUTE_FILE="${IP2ROUTE_FILE:-/config/data/default.lst}"

       DNSMASQ_IPSET="${DNSMASQ_IPSET:-/config/dnsmasq.ipset}"

[ -f "$DNSMASQ_IPSET" ] || echo "# dnsmasq servers, generated by ip2route.sh" > "$DNSMASQ_IPSET"

echocmd() {
    echo -e "--\\033[34m $(tr -s ' ' <<< "$*") \\033[0m"
    eval -- "$*"
}

is_host() { [[ "$*" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$         ]]; }
is_cidr() { [[ "$*" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$  ]]; }

# update_dnsmasq <domain> <set> <@dns>
update_dnsmasq() {
    # delete records
    sed -e "/server=\/$1\/*/d"  \
        -e "/ipset=\/$1\/*/d"   \
        -i "$DNSMASQ_IPSET"

    echo "ipset=/$1/$2"             >> "$DNSMASQ_IPSET"
    for s in ${@:3}; do
        echo "server=/$1/${s//:/#}" >> "$DNSMASQ_IPSET"
    done
}

# update_ipset path/to/some.ip [list]
update_ipset() {
    local name="$(basename "${1%.ip}")"
    local list="${2:-}"
    local cidr=0

    # scan for net cidr
    while read -r host; do
        is_cidr "$host" && cidr=1 && break
    done < "$1"

    #echo "cidr: $cidr"
    # destroy will fail if ipset is in use.
    ipset destroy "$name" &>/dev/null ||
    ipset flush "$name" &>/dev/null || true

    # create an ipset
    if [ "$cidr" -eq 0 ]; then
        echocmd ipset -exist create "$name" hash:ip
    else
        echocmd ipset -exist create "$name" hash:net
    fi

    #echo "ipset $name:"
    local dns=()
    while read -r line; do
		# remove spaces and tail comments
		IFS=' ' read -r host _ <<< "$line"

        [ -z "$host" ] && continue;
		[[ "$host" =~ ^# ]] && continue;

        # save dns
        [[ "$host" =~ ^@ ]] && dns+=("${host#@}") && continue

        #echo $host

        # add ip to set directly
        is_host "$host" && ipset -exist add "$name" "$host" && continue
        is_cidr "$host" && ipset -exist add "$name" "$host" && continue

        [ -z "${dns[*]}" ] || dns=("$IP2ROUTE_SERVER")
        update_dnsmasq "$host" "$name" "${dns[@]}"
    done < "$1"

    [ -z "$list" ] && return 0

    # add current ipset to list without flush
    echocmd ipset -exist add "$list" "$name"
}

# update_iplst path/to/some.lst [list]
update_iplst() {
    name="$(basename "${1%.lst}")"
    ipset flush "$name" &>/dev/null || true
    echocmd ipset -exist create "$name" list:set
    while read -r ips; do
        [[ $ips =~ '#' ]] && continue # ignore comments

        update_ipset "$(dirname "$1")/$ips" "$name" || return $?
    done < "$1"

    [ -z "$2" ] || echocmd ipset -exist add "$2" "$name"
    #ipset list $name
}

# flush fisrt
ip route del default table "$IP2ROUTE_ID" &>/dev/null || true
ip rule flush table "$IP2ROUTE_ID" &>/dev/null || true

# new table
if [ -n "$REMOTE_ADDR" ]; then
    echocmd ip route add default via "$REMOTE_ADDR" dev "$IP2ROUTE_DEV" table "$IP2ROUTE_ID" onlink 
else
    echocmd ip route add default dev "$IP2ROUTE_DEV" table "$IP2ROUTE_ID"
fi

# create a new route rule
echocmd ip rule add fwmark "$IP2ROUTE_ID" table "$IP2ROUTE_ID"

update_iplst "$IP2ROUTE_FILE"

# route ipset to dev
iptrule="-m set --match-set $(basename "${IP2ROUTE_FILE%.*}") dst -j MARK --set-mark $IP2ROUTE_ID"
# FORWARD
iptables -t mangle -C PREROUTING "$iptrule" 2>/dev/null ||
echocmd iptables -t mangle -I PREROUTING "$iptrule"
# OUTPUT
iptables -t mangle -C OUTPUT "$iptrule" 2>/dev/null ||
echocmd iptables -t mangle -I OUTPUT "$iptrule"
