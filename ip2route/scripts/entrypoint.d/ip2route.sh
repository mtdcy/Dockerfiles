#!/bin/bash -e
# ip route management script.
# Copyright (c) Chen Fang 2023, mtdcy.chen@gmail.com.
# 
# v0.3      - 20250421, modify for docker usage
# v0.2.1    - 20240613, add echocmd and fix tcpmss
# v0.2      - 20231125, code refactoring.
# 				   ...
# v0.1      - initial version

# root privilege is required
[ "$(id -u)" -eq 0 ] || exec sudo "$0" "$@"

# options           =
            ROUTE_ID="${ROUTE_ID:-1}"
        ROUTE_DEVICE="${ROUTE_DEVICE:-tun0}"
          ROUTE_ADDR="${ROUTE_ADDR:-}"
          ROUTE_FILE="${ROUTE_FILE:-/config/route/default.lst}"
         ROUTE_FLUSH="${ROUTE_FLUSH:-true}"

       DNSMASQ_IPSET="${DNSMASQ_IPSET:-/config/dnsmasq.ipset}"

iptables="${iptables:-$(which iptables)}"

echo "# dnsmasq servers, generated by ip2route.sh" > "$DNSMASQ_IPSET"

[ -z "$ROUTE_ADDR" ] || ROUTE_ADDR="${ROUTE_ADDR/:/#}"

info() {
    echo -e "ðŸš€\\033[32m $* \\033[0mðŸš€"
}

echocmd() {
    echo -e "--\\033[34m $* \\033[0m"
    "$@"
}

is_host() { [[ "$*" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$         ]]; }
is_cidr() { [[ "$*" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$  ]]; }

# update_dnsmasq <domain> <set> <@dns>
update_dnsmasq() {
    echo "ipset=/$1/$2"                             >> "$DNSMASQ_IPSET"
    # override dns with ROUTE_ADDR
    echo "server=/$1/${ROUTE_ADDR:-${3/:/#}}"  >> "$DNSMASQ_IPSET"
}

# update_ipset path/to/some.ip [list]
update_ipset() {
    local name="$(basename "${1%.*}")"
    local list="${2:-}"
    local cidr=0

    # scan for net cidr
    while read -r host; do
        is_cidr "$host" && cidr=1 && break
    done < "$1"

    #echo "cidr: $cidr"
    # destroy will fail if ipset is in use.
    if [ "$ROUTE_FLUSH" = "true" ]; then
        ipset -q destroy "$name" || ipset -q flush "$name" || true
    fi

    # create an ipset
    if [ "$cidr" -eq 0 ]; then
        echocmd ipset -exist create "$name" hash:ip
    else
        echocmd ipset -exist create "$name" hash:net
    fi

    #echo "ipset $name:"
    local dns
    while read -r line; do
		# remove spaces and tail comments
		IFS=' ' read -r host _ <<< "$line"

        [ -z "$host" ] && continue;
		[[ "$host" =~ ^# ]] && continue;

        # save dns
        [[ "$host" =~ ^@ ]] && dns="${host#@}" && continue

        #echo $host

        # add ip to set directly
        is_host "$host" && ipset -exist add "$name" "$host" && continue
        is_cidr "$host" && ipset -exist add "$name" "$host" && continue

        update_dnsmasq "$host" "$name" "$dns"
    done < "$1"

    [ -z "$list" ] && return 0

    # add current ipset to list without flush
    echocmd ipset -exist add "$list" "$name"
}

# update_iplst path/to/some.lst [list]
update_iplst() {
    name="$(basename "${1%.*}")"

    ipset destroy -q "$name" || ipset -q flush "$name" || true
    echocmd ipset -exist create "$name" list:set
    while read -r ips; do
        [[ $ips =~ '#' ]] && continue # ignore comments

        update_ipset "$(dirname "$1")/$ips" "$name" || return $?
    done < "$1"

    [ -z "$2" ] || echocmd ipset -exist add "$2" "$name"
    #ipset list $name
}

clean() {
    info "clean ip table $ROUTE_ID @$ROUTE_DEVICE"

    while read -r line; do
        echocmd "$iptables" -t mangle ${line/-A/-D} || true
    done < <("$iptables" -t mangle -S | grep -Fw -- "--set-xmark 0x$(printf "%x" "$ROUTE_ID")")

    echocmd ip route del default table "$ROUTE_ID" || true
    echocmd ip rule flush table "$ROUTE_ID" || true
}

# always clean first
clean

[ "$1" = clean ] && exit 0

[ -f "$ROUTE_FILE" ] || {
    info "$ROUTE_FILE not exists"
    exit 1
}
info "init ip table $ROUTE_ID @$ROUTE_DEVICE - $ROUTE_ADDR"

# new table
if [ -n "$ROUTE_ADDR" ]; then
    echocmd ip route add default via "$ROUTE_ADDR" dev "$ROUTE_DEVICE" table "$ROUTE_ID" proto static onlink ||
    echocmd ip route rep default via "$ROUTE_ADDR" dev "$ROUTE_DEVICE" table "$ROUTE_ID" proto static onlink
else
    echocmd ip route add default dev "$ROUTE_DEVICE" table "$ROUTE_ID" proto static ||
    echocmd ip route rep default dev "$ROUTE_DEVICE" table "$ROUTE_ID" proto static
fi

# create a new route rule
echocmd ip rule add fwmark "$ROUTE_ID" table "$ROUTE_ID"

# create ipset
[[ "$ROUTE_FILE" =~ .lst$ ]] && update_iplst "$ROUTE_FILE" || update_ipset "$ROUTE_FILE"

iptrule=( -m set --match-set "$(basename "${ROUTE_FILE%.*}")" dst -j MARK --set-mark "$ROUTE_ID" )

# route OUTPUT
echocmd "$iptables" -t mangle -I OUTPUT "${iptrule[@]}"

# exclude route device
iptrule+=( ! -i "$ROUTE_DEVICE" )

# route FORWARD
echocmd "$iptables" -t mangle -I PREROUTING "${iptrule[@]}"

# iptables mark will always use default device ip, so MASQUERADE is neccesary
echocmd "$iptables" -t nat -C POSTROUTING -o "$ROUTE_DEVICE" -j MASQUERADE ||
echocmd "$iptables" -t nat -A POSTROUTING -o "$ROUTE_DEVICE" -j MASQUERADE
